%!TEX root = spadini_davide.tex

\chapter*{Introduction} % senza numerazione
\label{sommario}

\addcontentsline{toc}{chapter}{Introduction} % da aggiungere comunque all'indice
Gossip-based communication protocols have been successfully applied in large-scale systems with important applications which include information dissemination, aggregation, overlay topology management and synchronization. The common property of these protocols is that each node in the system periodically exchanges information with a subset of its peers. The choice of this subset is crucial to the wide dissemination of the information. Ideally, any given node should exchange information with peers that are selected following a uniform random sample from \textit{all} nodes currently in the system. However, providing each node with a complete membership table from which a random sample can be drawn, is unrealistic in a large-scale dynamic system, because maintaining such tables in the presence of churn (meaning that nodes can join or leave at any given point in time) incurs considerable synchronization costs. 

The Peer Sampling Service (PSS) is a fundamental distributed component of gossip-based protocols that provides each node with a list of peers. A PSS can be implemented as a centralized service, using gossip protocols or random walks. Gossip-based PSSes~\cite{gossip_protocol} have been the most widely adopted solution, as centralized PSSes are expensive to run reliably, and random walks are only suitable for stable networks, i.e. with very low levels of churn. 

In order to handle situations in which the nodes cannot communicate directly with one another, for example because the nodes reside behind Network Address Translation Gateways (NATs) and firewalls, NAT-aware gossip-based PSSes have been introduced, capable to generate uniformly random samples even for systems with a high percentage of private nodes, that is, nodes that reside behind a NAT and/or firewall. 

State-of-the-art NAT-aware gossip protocols, such as Gozar~\cite{gozar} or Croupier~\cite{croupier}, require peers to frequently establish network connections and exchange messages with public nodes (i.e., nodes that support direct connectivity), in order to build a view of the overlay network. This design is based on two assumptions: the first one is that the connection establishment from a private to a public peer comes at negligible cost, and the second one is that the connection setup time is short. However, in many Peer-To-Peer applications like for example Google WebRTC~\cite{webrtc}, these assumptions do not hold. In general, establishing a connection is a relatively complex and costly procedure: for security reasons but also to overcome the problems of NATs traversal. 

As a solution to these issues, the \ac{WPSS}~\cite{wormhole} protocol has been introduced in 2013, which provides the same properties of other PSSes (freshness of samples, randomness, robustness to different level of churn, NAT-friendliness) while it decreases the connection establishment rate by one order of magnitude. 

The goal of this thesis is to provide an alternative implementation of this algorithm, using WebRTC as ``network handler''. WebRTC is an Application Programming Interface (API) definition that supports browser-to-browser applications. It is already implemented in Chrome, Firefox and Opera browsers, and it is perfectly suitable for our purpose because it could be used from multiple types of device (personal computer, but also smart-phones) since it works on browsers. In this way our implementation could be used to build a peer-to-peer application connecting smartphones to  personal computers.

We will show that our implementation maintains the same properties as the original while it is more robust to churn. We also give an implementation of a gossip-based aggregation protocol that is built on top of our PSS, testing it with several experiments and measuring the convergence time.

Section~\ref{cha:webrtc} introduces WebRTC. Section~\ref{cha:wormhole} explains the \ac{WPSS} algorithm, while Section~\ref{cha:implementation} discusses the main differences between our implementation and the original one. In Section~\ref{cha:evaluation}, we evaluate our protocol through numerous tests in a emulation environment; an implementation of a gossip-based aggregation protocol is described and tested in Section~\ref{cha:aggregation}. In the final conclusions, Section~\ref{cha:conclusions}, we discuss the obtained results, the limitations of our model and some suggestions for possible enhancements.
