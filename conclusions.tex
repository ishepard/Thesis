%!TEX root = spadini_davide.tex

\chapter{Conclusions and Further Works}
\label{cha:conclusions}
In this project we presented an implementation of the WPSS, an important service that provides the same level of sample freshness as other NAT-aware PSSes, but achieves that with a connection establishment rate that is one order of magnitude lower. We implemented it using WebRTC as ``network handler'', meaning that it is responsible for the creation and the maintenance of the connections between peers.

We showed, through several of experiments in which we compared our results with theirs, that our implementation maintains the same properties as the original. We saw that it has a good level of sample freshness and randomness. WebRTC perfectly manages the connections, maintaining the nodes degree fixed. In this way, it allows us to correctly handle particular and difficult cases, such as a flash crowd scenario or, even worst, a catastrophic scenario in which the majority of nodes fail in a given point in time. In this case we saw that even when 80\% of nodes exit, the network stays connected and the remaining nodes keep running the algorithm. 

We also noticed that our implementation is robust to various levels of churn, in which a percentage of nodes fail and join every 10 seconds. In this case it behaves better than the original, because WebRTC, which is responsible for the maintenance of the network, replaces faster the broken links with new ones. 

In order to support our implementation we built on top of it a gossip-based aggregation protocol, which is a peer-to-peer application that uses our underlying service to compute some operations. We compared our results with the ones reported in~\cite{aggregation} and we saw that they perfectly match. As the test have demonstrated, the application acts like expected, confirming the correctness of our implementation of the WPSS. 

Some refinements could be considered to improve the reliability of this implementation. First of all, we implemented the tracker as a central service. The tracker is contacted at bootstrap time and when a node needs a reference of a new peer. The WPSS is designed to keep the number of new connections created as low as possible. However, in presence of churn, the tracker could be a bottleneck, because it has relatively high load and it may waste resources. Another important case is that, when the tracker crashes, no-one can get a reference of a new node. Handling the latter situation is simpler, we could just insert a second tracker that acts as a backup server; in this way when the primary server crashes, all the requests go automatically to the secondary one. This does not solve the problem of churn, that could be solved only by inserting 2 primary servers and dividing the traffic between them. 

The same problem occurs with the EasyRTC server, which has to register all the nodes inside the network. Even in this case, there is the possibility to add redundancy in the system, creating more than one server in order to have some of them that acts as backup servers. Then, each node decides which of them to contact, and if for some reasons that server goes down, it connects to another one. 
